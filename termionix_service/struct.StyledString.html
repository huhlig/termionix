<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Represents a string with internal data for the ANSI escape sequences, so it can be constructed when the `Display` is called. It is preferred to use the `Styled` trait to interact with your strings instead of manually constructing a `StyledString`, which is more verbose."><title>StyledString in termionix_service - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="termionix_service" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0 (254b59607 2026-01-19)" data-channel="1.93.0" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">StyledString</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../termionix_service/index.html">termionix_<wbr>service</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Styled<wbr>String</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.clear" title="clear">clear</a></li><li><a href="#method.concat" title="concat">concat</a></li><li><a href="#method.concat_with_style" title="concat_with_style">concat_with_style</a></li><li><a href="#method.empty" title="empty">empty</a></li><li><a href="#method.from_string" title="from_string">from_string</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.pop" title="pop">pop</a></li><li><a href="#method.push" title="push">push</a></li><li><a href="#method.push_str" title="push_str">push_str</a></li><li><a href="#method.segmented" title="segmented">segmented</a></li><li><a href="#method.set_style" title="set_style">set_style</a></li><li><a href="#method.stripped" title="stripped">stripped</a></li><li><a href="#method.stripped_len" title="stripped_len">stripped_len</a></li><li><a href="#method.styled_len" title="styled_len">styled_len</a></li><li><a href="#method.write_str" title="write_str">write_str</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add-for-StyledString" title="Add">Add</a></li><li><a href="#impl-Clone-for-StyledString" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-StyledString" title="Debug">Debug</a></li><li><a href="#impl-Default-for-StyledString" title="Default">Default</a></li><li><a href="#impl-Eq-for-StyledString" title="Eq">Eq</a></li><li><a href="#impl-FromStr-for-StyledString" title="FromStr">FromStr</a></li><li><a href="#impl-PartialEq-for-StyledString" title="PartialEq">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-StyledString" title="StructuralPartialEq">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-StyledString" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-StyledString" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-StyledString" title="Send">Send</a></li><li><a href="#impl-Sync-for-StyledString" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-StyledString" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-StyledString" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate termionix_<wbr>service</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">termionix_service</a></div><h1>Struct <span class="struct">Styled<wbr>String</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub struct StyledString { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Represents a string with internal data for the ANSI escape sequences, so it
can be constructed when the <code>Display</code> is called. It is preferred to use the
<code>Styled</code> trait to interact with your strings instead of manually
constructing a <code>StyledString</code>, which is more verbose.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">¬ß</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-StyledString" class="impl"><a href="#impl-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.empty" class="method"><h4 class="code-header">pub fn <a href="#method.empty" class="fn">empty</a>() -&gt; <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h4></section></summary><div class="docblock"><p>Creates a new empty <code>StyledString</code> with no segments.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span>styled = StyledString::empty();
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">0</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_string" class="method"><h4 class="code-header">pub fn <a href="#method.from_string" class="fn">from_string</a>(
    str: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.str.html">str</a>,
    style: <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.AnsiSelectGraphicRendition.html" title="struct termionix_service::AnsiSelectGraphicRendition">AnsiSelectGraphicRendition</a>&gt;,
) -&gt; <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h4></section></summary><div class="docblock"><p>Creates a new <code>StyledString</code> from a string slice with an optional style.</p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">¬ß</a>Arguments</h5>
<ul>
<li><code>str</code> - The text content to create the styled string from</li>
<li><code>style</code> - Optional style to apply to the entire string. If <code>None</code>, uses default style.</li>
</ul>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color, Intensity};

<span class="comment">// Create without style
</span><span class="kw">let </span>plain = StyledString::from_string(<span class="string">"Hello"</span>, <span class="prelude-val">None</span>);

<span class="comment">// Create with style
</span><span class="kw">let </span>styled = StyledString::from_string(<span class="string">"Hello"</span>, <span class="prelude-val">Some</span>(Style {
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    ..Default::default()
}));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Check if StyledString is empty</p>
<p>Returns <code>true</code> if the styled string contains no segments or if all segments are empty.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span>empty = StyledString::empty();
<span class="macro">assert!</span>(empty.is_empty());

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat(<span class="string">"Hello"</span>);
<span class="macro">assert!</span>(!styled.is_empty());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.stripped_len" class="method"><h4 class="code-header">pub fn <a href="#method.stripped_len" class="fn">stripped_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total length of the stripped string in bytes.</p>
<p>This sums up the lengths of all segments in the styled string.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::utility::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat(<span class="string">"Hello"</span>);
styled.concat(<span class="string">" World"</span>);
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">11</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.styled_len" class="method"><h4 class="code-header">pub fn <a href="#method.styled_len" class="fn">styled_len</a>(
    &amp;self,
    config: <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.AnsiConfig.html" title="struct termionix_service::AnsiConfig">AnsiConfig</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.AnsiCodecError.html" title="enum termionix_service::AnsiCodecError">AnsiCodecError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the total length of the styled string including ANSI escape codes
for the specified color mode.</p>
<h5 id="arguments-1"><a class="doc-anchor" href="#arguments-1">¬ß</a>Arguments</h5>
<ul>
<li><code>mode</code> - The color mode determining which ANSI codes to include in the length calculation</li>
</ul>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{ ColorMode, AnsiConfig};
<span class="kw">use </span>termionix_ansicodec::ansi::{Color, Intensity};
<span class="kw">use </span>termionix_ansicodec::utility::StyledString;

<span class="kw">let </span>config = AnsiConfig::enabled();
<span class="kw">let </span>styled = StyledString::from_string(<span class="string">"Hello"</span>, <span class="prelude-val">Some</span>(Style {
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    ..Default::default()
}));
<span class="kw">let </span>len = styled.styled_len(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>config));
<span class="macro">assert!</span>(len &gt; <span class="number">5</span>); <span class="comment">// Longer than just "Hello" due to ANSI codes</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clears all content from the <code>StyledString</code>, removing all segments and styles.</p>
<p>This method resets the styled string to an empty state, equivalent to creating
a new <code>StyledString</code> with <a href="struct.StyledString.html#method.empty" title="associated function termionix_service::StyledString::empty"><code>StyledString::empty()</code></a>. All text content and
associated styling information is discarded.</p>
<p>After calling this method:</p>
<ul>
<li><a href="struct.StyledString.html#method.stripped_len" title="method termionix_service::StyledString::stripped_len"><code>len()</code></a> will return 0</li>
<li><a href="struct.StyledString.html#method.is_empty" title="method termionix_service::StyledString::is_empty"><code>is_empty()</code></a> will return <code>true</code></li>
<li><a href="struct.StyledString.html#method.stripped" title="method termionix_service::StyledString::stripped"><code>stripped()</code></a> will return an empty string</li>
<li>All internal segments and their styles are removed</li>
</ul>
<h5 id="performance"><a class="doc-anchor" href="#performance">¬ß</a>Performance</h5>
<p>This is an efficient operation that simply clears the internal segment vector.
The underlying memory capacity is retained, making subsequent operations
potentially more efficient if the <code>StyledString</code> is reused.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">¬ß</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::utility::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat(<span class="string">"Hello World"</span>);
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">11</span>);

styled.clear();
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">0</span>);
<span class="macro">assert!</span>(styled.is_empty());</code></pre></div>
<p>Clearing styled content:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color, Intensity};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::from_string(<span class="string">"Bold Text"</span>, <span class="prelude-val">Some</span>(Style {
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    ..Default::default()
}));

styled.clear();
<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">""</span>);</code></pre></div>
<p>Reusing after clear:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat(<span class="string">"First message"</span>);
styled.clear();

<span class="comment">// Reuse the same StyledString
</span>styled.concat(<span class="string">"Second message"</span>);
<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Second message"</span>);</code></pre></div>
<p>Clearing multiple segments:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat(<span class="string">"Normal "</span>);
styled.concat_with_style(<span class="string">"Red"</span>, Style {
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    ..Default::default()
});
styled.concat_with_style(<span class="string">" Blue"</span>, Style {
    foreground: <span class="prelude-val">Some</span>(Color::Blue),
    ..Default::default()
});

styled.clear();
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">0</span>);</code></pre></div><h5 id="see-also"><a class="doc-anchor" href="#see-also">¬ß</a>See Also</h5>
<ul>
<li><a href="struct.StyledString.html#method.empty" title="associated function termionix_service::StyledString::empty"><code>StyledString::empty()</code></a> - Create a new empty styled string</li>
<li><a href="struct.StyledString.html#method.is_empty" title="method termionix_service::StyledString::is_empty"><code>StyledString::is_empty()</code></a> - Check if the string is empty</li>
<li><a href="struct.StyledString.html#method.stripped_len" title="method termionix_service::StyledString::stripped_len"><code>StyledString::len()</code></a> - Get the length of the string</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><h4 class="code-header">pub fn <a href="#method.push" class="fn">push</a>(&amp;mut self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.char.html">char</a>)</h4></section></summary><div class="docblock"><p>Appends a single character to the end of this <code>StyledString</code>.</p>
<p>This method behaves similarly to <a href="https://doc.rust-lang.org/1.93.0/alloc/string/struct.String.html#method.push" title="method alloc::string::String::push"><code>String::push()</code></a>, appending a character
to the last segment in the styled string. If the styled string is empty,
a new segment with default styling is created.</p>
<p>The character is added to the last segment‚Äôs buffer, and the segment‚Äôs
range is extended accordingly. This preserves the existing style of the
last segment rather than creating a new segment for each character.</p>
<h5 id="arguments-2"><a class="doc-anchor" href="#arguments-2">¬ß</a>Arguments</h5>
<ul>
<li><code>ch</code> - The character to append to the styled string</li>
</ul>
<h5 id="performance-1"><a class="doc-anchor" href="#performance-1">¬ß</a>Performance</h5>
<p>This operation is efficient for building strings character-by-character,
as it reuses existing segments rather than creating new ones for each
character. The underlying buffer may reallocate if it needs to grow.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">¬ß</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push(<span class="string">'H'</span>);
styled.push(<span class="string">'i'</span>);
styled.push(<span class="string">'!'</span>);

<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Hi!"</span>);
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">3</span>);</code></pre></div>
<p>Unicode character support:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push(<span class="string">'ü¶Ä'</span>); <span class="comment">// Rust crab emoji (4 bytes in UTF-8)
</span>styled.push(<span class="string">'Êó•'</span>); <span class="comment">// Japanese character (3 bytes in UTF-8)

</span><span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"ü¶ÄÊó•"</span>);
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">7</span>); <span class="comment">// 4 + 3 bytes</span></code></pre></div>
<p>Building styled text character by character:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color, Intensity};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::from_string(<span class="string">"Bold"</span>, <span class="prelude-val">Some</span>(Style {
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    ..Default::default()
}));

<span class="comment">// Characters pushed after the initial creation inherit the last segment's style
</span>styled.push(<span class="string">'!'</span>);

<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Bold!"</span>);</code></pre></div><h5 id="see-also-1"><a class="doc-anchor" href="#see-also-1">¬ß</a>See Also</h5>
<ul>
<li><a href="struct.StyledString.html#method.concat" title="method termionix_service::StyledString::concat"><code>concat()</code></a> - Append an entire string with default styling</li>
<li><a href="struct.StyledString.html#method.concat_with_style" title="method termionix_service::StyledString::concat_with_style"><code>concat_with_style()</code></a> - Append a string with specific styling</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_str" class="method"><h4 class="code-header">pub fn <a href="#method.push_str" class="fn">push_str</a>&lt;S&gt;(&amp;mut self, str: S)<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Appends a string slice to the end of this <code>StyledString</code>.</p>
<p>This method behaves similarly to <a href="https://doc.rust-lang.org/1.93.0/alloc/string/struct.String.html#method.push_str" title="method alloc::string::String::push_str"><code>String::push_str()</code></a>, appending a string
to the last segment in the styled string. If the styled string is empty,
a new segment with default styling is created. Empty strings are ignored
and don‚Äôt affect the styled string.</p>
<p>The string is added to the last segment‚Äôs buffer, and the segment‚Äôs
range is extended accordingly. This preserves the existing style of the
last segment rather than creating a new segment for each string.</p>
<h5 id="arguments-3"><a class="doc-anchor" href="#arguments-3">¬ß</a>Arguments</h5>
<ul>
<li><code>str</code> - A value that can be referenced as a string slice (e.g., <code>&amp;str</code>, <code>String</code>, <code>&amp;String</code>)</li>
</ul>
<h5 id="performance-2"><a class="doc-anchor" href="#performance-2">¬ß</a>Performance</h5>
<p>This operation is efficient for building strings incrementally, as it reuses
existing segments rather than creating new ones for each string. The underlying
buffer may reallocate if it needs to grow.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">¬ß</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push_str(<span class="string">"Hello"</span>);
styled.push_str(<span class="string">" "</span>);
styled.push_str(<span class="string">"World"</span>);

<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Hello World"</span>);
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">11</span>);</code></pre></div>
<p>Accepting different string types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push_str(<span class="string">"str slice"</span>);           <span class="comment">// &amp;str
</span>styled.push_str(<span class="kw-2">&amp;</span>String::from(<span class="string">" String"</span>)); <span class="comment">// &amp;String
</span>styled.push_str(String::from(<span class="string">" owned"</span>)); <span class="comment">// String

</span><span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"str slice String owned"</span>);</code></pre></div>
<p>Unicode string support:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push_str(<span class="string">"Hello "</span>);
styled.push_str(<span class="string">"‰∏ñÁïå"</span>);  <span class="comment">// "World" in Japanese
</span>styled.push_str(<span class="string">"! ü¶Ä"</span>); <span class="comment">// With emoji

</span><span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Hello ‰∏ñÁïå! ü¶Ä"</span>);</code></pre></div>
<p>Building styled text string by string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color, Intensity};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::from_string(<span class="string">"Bold text"</span>, <span class="prelude-val">Some</span>(Style {
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    ..Default::default()
}));

<span class="comment">// Strings pushed after the initial creation inherit the last segment's style
</span>styled.push_str(<span class="string">" continues"</span>);

<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Bold text continues"</span>);</code></pre></div>
<p>Empty strings are no-ops:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push_str(<span class="string">""</span>);
styled.push_str(<span class="string">"Hello"</span>);
styled.push_str(<span class="string">""</span>);

<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Hello"</span>);
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">5</span>);</code></pre></div><h5 id="see-also-2"><a class="doc-anchor" href="#see-also-2">¬ß</a>See Also</h5>
<ul>
<li><a href="struct.StyledString.html#method.push" title="method termionix_service::StyledString::push"><code>push()</code></a> - Append a single character</li>
<li><a href="struct.StyledString.html#method.concat" title="method termionix_service::StyledString::concat"><code>concat()</code></a> - Append a string with default styling</li>
<li><a href="struct.StyledString.html#method.concat_with_style" title="method termionix_service::StyledString::concat_with_style"><code>concat_with_style()</code></a> - Append a string with specific styling</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop" class="method"><h4 class="code-header">pub fn <a href="#method.pop" class="fn">pop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.char.html">char</a>&gt;</h4></section></summary><div class="docblock"><p>Removes the last character from this <code>StyledString</code> and returns it,
or <code>None</code> if the string is empty.</p>
<p>This method behaves similarly to <a href="https://doc.rust-lang.org/1.93.0/alloc/string/struct.String.html#method.pop" title="method alloc::string::String::pop"><code>String::pop()</code></a>, removing a character
from the last segment in the styled string. If removing the character
leaves a segment empty, that segment is removed. The segment‚Äôs range
is adjusted accordingly.</p>
<h5 id="returns"><a class="doc-anchor" href="#returns">¬ß</a>Returns</h5>
<p>Returns <code>Some(char)</code> containing the last character if the string is not empty,
or <code>None</code> if the string is empty.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">¬ß</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push(<span class="string">'a'</span>);
styled.push(<span class="string">'b'</span>);
styled.push(<span class="string">'c'</span>);

<span class="macro">assert_eq!</span>(styled.pop(), <span class="prelude-val">Some</span>(<span class="string">'c'</span>));
<span class="macro">assert_eq!</span>(styled.pop(), <span class="prelude-val">Some</span>(<span class="string">'b'</span>));
<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"a"</span>);</code></pre></div>
<p>Popping from an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
<span class="macro">assert_eq!</span>(styled.pop(), <span class="prelude-val">None</span>);</code></pre></div>
<p>Unicode character support:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.push(<span class="string">'ü¶Ä'</span>); <span class="comment">// Rust crab emoji (4 bytes in UTF-8)
</span>styled.push(<span class="string">'Êó•'</span>); <span class="comment">// Japanese character (3 bytes in UTF-8)

</span><span class="macro">assert_eq!</span>(styled.pop(), <span class="prelude-val">Some</span>(<span class="string">'Êó•'</span>));
<span class="macro">assert_eq!</span>(styled.pop(), <span class="prelude-val">Some</span>(<span class="string">'ü¶Ä'</span>));
<span class="macro">assert_eq!</span>(styled.pop(), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.concat" class="method"><h4 class="code-header">pub fn <a href="#method.concat" class="fn">concat</a>(&amp;mut self, str: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Appends a string to the end of this <code>StyledString</code> with default styling.</p>
<h5 id="arguments-4"><a class="doc-anchor" href="#arguments-4">¬ß</a>Arguments</h5>
<ul>
<li><code>str</code> - The text to append</li>
</ul>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat(<span class="string">"Hello"</span>);
styled.concat(<span class="string">" World"</span>);
<span class="macro">assert_eq!</span>(styled.stripped_len(), <span class="number">11</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.concat_with_style" class="method"><h4 class="code-header">pub fn <a href="#method.concat_with_style" class="fn">concat_with_style</a>(
    &amp;mut self,
    str: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.str.html">str</a>,
    style: <a class="struct" href="struct.AnsiSelectGraphicRendition.html" title="struct termionix_service::AnsiSelectGraphicRendition">AnsiSelectGraphicRendition</a>,
)</h4></section></summary><div class="docblock"><p>Appends a string to the end of this <code>StyledString</code> with the specified style.</p>
<h5 id="arguments-5"><a class="doc-anchor" href="#arguments-5">¬ß</a>Arguments</h5>
<ul>
<li><code>str</code> - The text to append</li>
<li><code>style</code> - The style to apply to the appended text</li>
</ul>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color, Intensity};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat(<span class="string">"Normal "</span>);
styled.concat_with_style(<span class="string">"Bold"</span>, Style {
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    ..Default::default()
});</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_style" class="method"><h4 class="code-header">pub fn <a href="#method.set_style" class="fn">set_style</a>(
    &amp;mut self,
    style: <a class="struct" href="struct.AnsiSelectGraphicRendition.html" title="struct termionix_service::AnsiSelectGraphicRendition">AnsiSelectGraphicRendition</a>,
    range: <a class="struct" href="https://doc.rust-lang.org/1.93.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.usize.html">usize</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Applies a style to a specific range of the string.</p>
<p>This method splits segments as necessary to apply the style only to the specified range.
If the range overlaps multiple segments, each segment is split appropriately, creating
new segments for the portions before, within, and after the styled range.</p>
<h5 id="arguments-6"><a class="doc-anchor" href="#arguments-6">¬ß</a>Arguments</h5>
<ul>
<li><code>style</code> - The style to apply</li>
<li><code>range</code> - The byte range to apply the style to (start..end)</li>
</ul>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">use </span>termionix_ansicodec::ansi::Underline;
<span class="kw">use </span>termionix_ansicodec::utility::StyledString;
<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::from_string(<span class="string">"Hello World"</span>, <span class="prelude-val">None</span>);
styled.set_style(Style {
    underline: <span class="prelude-val">Some</span>(Underline::Single),
    ..Default::default()
}, <span class="number">6</span>..<span class="number">11</span>); <span class="comment">// Underline "World"</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.stripped" class="method"><h4 class="code-header">pub fn <a href="#method.stripped" class="fn">stripped</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.93.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the string content without any ANSI styling codes.</p>
<p>This method concatenates all segment buffers into a plain string,
effectively stripping all styling information.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">use </span>termionix_ansicodec::ansi::{Color, Intensity};
<span class="kw">use </span>termionix_ansicodec::utility::StyledString;

<span class="kw">let </span>styled = StyledString::from_string(<span class="string">"Hello"</span>, <span class="prelude-val">Some</span>(Style {
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    ..Default::default()
}));
<span class="macro">assert_eq!</span>(styled.stripped(), <span class="string">"Hello"</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.segmented" class="method"><h4 class="code-header">pub fn <a href="#method.segmented" class="fn">segmented</a>(&amp;self) -&gt; <a class="struct" href="struct.SegmentedString.html" title="struct termionix_service::SegmentedString">SegmentedString</a></h4></section></summary><div class="docblock"><p>Converts this <code>StyledString</code> into a <code>SegmentedString</code> with explicit style segments.</p>
<p>This method transforms a <code>StyledString</code> that stores text with styling metadata
into a <code>SegmentedString</code> with explicit SGR (Select Graphic Rendition) segments.
Each styled segment in the <code>StyledString</code> is converted into a sequence of segments
in the resulting <code>SegmentedString</code>:</p>
<ol>
<li>An SGR segment with the style (if not default)</li>
<li>The text content</li>
<li>A style reset SGR segment (if styling was applied)</li>
</ol>
<p>This conversion is useful when you need to:</p>
<ul>
<li>Generate ANSI escape sequences for terminal output</li>
<li>Convert styled text to a format with explicit control over segments</li>
<li>Preserve the exact structure of styles and resets</li>
<li>Interface with systems that expect explicit style boundaries</li>
</ul>
<h5 id="segment-generation"><a class="doc-anchor" href="#segment-generation">¬ß</a>Segment Generation</h5>
<p>For each internal segment with style and text:</p>
<ul>
<li><strong>Non-default style</strong>: Generates <code>SGR(style) ‚Üí Text ‚Üí SGR(default)</code></li>
<li><strong>Default style</strong>: Generates only <code>Text</code> (no style segments)</li>
</ul>
<p>This ensures that styles are properly scoped and reset, preventing style
‚Äúbleed‚Äù into subsequent segments.</p>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">¬ß</a>Returns</h5>
<p>A new <code>SegmentedString</code> containing:</p>
<ul>
<li>SGR segments for style changes</li>
<li>Text segments (ASCII or Unicode) for content</li>
<li>SGR reset segments after each styled portion</li>
</ul>
<h5 id="performance-3"><a class="doc-anchor" href="#performance-3">¬ß</a>Performance</h5>
<p>This is an O(n) operation where n is the number of segments in the <code>StyledString</code>.
Each segment is processed once, and the resulting <code>SegmentedString</code> may contain
up to 3√ó the number of segments (style, text, reset for each styled segment).</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">¬ß</a>Examples</h5>
<p>Basic conversion:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color, Intensity};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat_with_style(<span class="string">"Error"</span>, Style {
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    intensity: <span class="prelude-val">Some</span>(Intensity::Bold),
    ..Default::default()
});

<span class="kw">let </span>segmented = styled.segmented();
<span class="comment">// Results in: SGR(red+bold) ‚Üí "Error" ‚Üí SGR(reset)
</span><span class="macro">assert!</span>(segmented.segment_count() &gt;= <span class="number">1</span>);</code></pre></div>
<p>Multiple styled segments:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::empty();
styled.concat_with_style(<span class="string">"Red"</span>, Style {
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    ..Default::default()
});
styled.concat(<span class="string">" "</span>); <span class="comment">// Default style
</span>styled.concat_with_style(<span class="string">"Blue"</span>, Style {
    foreground: <span class="prelude-val">Some</span>(Color::Blue),
    ..Default::default()
});

<span class="kw">let </span>segmented = styled.segmented();
<span class="comment">// Results in: SGR(red) ‚Üí "Red" ‚Üí SGR(reset) ‚Üí " " ‚Üí SGR(blue) ‚Üí "Blue" ‚Üí SGR(reset)</span></code></pre></div>
<p>Plain text without styling:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::StyledString;

<span class="kw">let </span>styled = StyledString::from_string(<span class="string">"Plain text"</span>, <span class="prelude-val">None</span>);
<span class="kw">let </span>segmented = styled.segmented();

<span class="comment">// Only text segments, no style segments
</span><span class="macro">assert_eq!</span>(segmented.stripped(), <span class="string">"Plain text"</span>);</code></pre></div>
<p>Complex styling with range-based styles:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{StyledString, Style, Color};

<span class="kw">let </span><span class="kw-2">mut </span>styled = StyledString::from_string(<span class="string">"Hello World"</span>, <span class="prelude-val">None</span>);
styled.set_style(Style {
    foreground: <span class="prelude-val">Some</span>(Color::Red),
    ..Default::default()
}, <span class="number">0</span>..<span class="number">5</span>); <span class="comment">// Style "Hello"

</span><span class="kw">let </span>segmented = styled.segmented();
<span class="comment">// Converts the split segments into explicit style boundaries</span></code></pre></div><h5 id="use-cases"><a class="doc-anchor" href="#use-cases">¬ß</a>Use Cases</h5>
<ul>
<li><strong>Terminal output</strong>: Generate ANSI codes for displaying styled text</li>
<li><strong>Serialization</strong>: Convert to a format with explicit style boundaries</li>
<li><strong>Protocol compatibility</strong>: Interface with systems expecting SGR segments</li>
<li><strong>Testing</strong>: Verify style application and reset behavior</li>
<li><strong>Format conversion</strong>: Bridge between <code>StyledString</code> and <code>SegmentedString</code></li>
</ul>
<h5 id="comparison-with-other-conversions"><a class="doc-anchor" href="#comparison-with-other-conversions">¬ß</a>Comparison with Other Conversions</h5>
<ul>
<li><a href="struct.SpannedString.html#method.into_segmented_string" title="method termionix_service::SpannedString::into_segmented_string"><code>SpannedString::into_segmented_string</code></a>:
Converts byte ranges to segments by extracting from source string</li>
<li><code>StyledString::into_segmented_string</code>: Converts style metadata to explicit SGR segments</li>
<li>Both produce <code>SegmentedString</code> but from different source representations</li>
</ul>
<h5 id="style-reset-behavior"><a class="doc-anchor" href="#style-reset-behavior">¬ß</a>Style Reset Behavior</h5>
<p>The method ensures clean style boundaries by:</p>
<ol>
<li>Emitting an SGR segment before each styled text portion</li>
<li>Always resetting to default style after styled portions</li>
<li>Skipping style segments for text with default styling</li>
</ol>
<p>This prevents styles from unintentionally affecting subsequent text.</p>
<h5 id="see-also-3"><a class="doc-anchor" href="#see-also-3">¬ß</a>See Also</h5>
<ul>
<li><a href="struct.SegmentedString.html" title="struct termionix_service::SegmentedString"><code>SegmentedString</code></a> - The target type with explicit segments</li>
<li><a href="struct.SegmentedString.html#method.push_style" title="method termionix_service::SegmentedString::push_style"><code>SegmentedString::push_style</code></a> - How style segments are added</li>
<li><a href="struct.SegmentedString.html#method.push_str" title="method termionix_service::SegmentedString::push_str"><code>SegmentedString::push_str</code></a> - How text segments are added</li>
<li>[<code>SpannedString::into_segmented_string</code>] - Similar conversion from parsed spans</li>
<li><a href="struct.AnsiSelectGraphicRendition.html" title="struct termionix_service::AnsiSelectGraphicRendition"><code>AnsiSelectGraphicRendition</code></a> - The style type used in SGR segments</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_str" class="method"><h4 class="code-header">pub fn <a href="#method.write_str" class="fn">write_str</a>&lt;W&gt;(
    &amp;self,
    writer: <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.reference.html">&amp;mut W</a>,
    config: <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.AnsiConfig.html" title="struct termionix_service::AnsiConfig">AnsiConfig</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.93.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;<div class="where">where
    W: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/fmt/trait.Write.html" title="trait core::fmt::Write">Write</a>,</div></h4></section></summary><div class="docblock"><p>Writes the styled string with ANSI escape codes to a writer.</p>
<p>This method generates the appropriate ANSI escape sequences based on the
color mode and writes them along with the text content to the provided writer.
Each segment is written with its opening ANSI codes, content, and a reset code.</p>
<h5 id="arguments-7"><a class="doc-anchor" href="#arguments-7">¬ß</a>Arguments</h5>
<ul>
<li><code>mode</code> - The color mode determining which ANSI codes to generate (None, Basic, Extended, TrueColor)</li>
<li><code>writer</code> - The writer to output the styled string to</li>
</ul>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">¬ß</a>Returns</h5>
<p>Returns <code>Ok(())</code> on success, or a <code>std::fmt::Error</code> if writing fails.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>termionix_ansicodec::{ColorMode, AnsiConfig};
<span class="kw">use </span>termionix_ansicodec::utility::StyledString;

<span class="kw">let </span>config = AnsiConfig::default();
<span class="kw">let </span>styled = StyledString::from_string(<span class="string">"Hello"</span>, <span class="prelude-val">None</span>);
<span class="kw">let </span><span class="kw-2">mut </span>output = String::new();
styled.write_str(<span class="kw-2">&amp;mut </span>output, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>config)).unwrap();</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">¬ß</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add-for-StyledString" class="impl"><a href="#impl-Add-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a href="#method.add" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a>) -&gt; <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.93.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-StyledString" class="impl"><a href="#impl-Clone-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a href="#method.clone" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.93.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="https://doc.rust-lang.org/1.93.0/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.93.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-StyledString" class="impl"><a href="#impl-Debug-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.93.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.93.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.93.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-StyledString" class="impl"><a href="#impl-Default-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a href="#method.default" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h4></section></summary><div class='docblock'>Returns the ‚Äúdefault value‚Äù for a type. <a href="https://doc.rust-lang.org/1.93.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-StyledString" class="impl"><a href="#impl-FromStr-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a href="#associatedtype.Err" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.unit.html">()</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a href="#method.from_str" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a>, &lt;<a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a> as <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.93.0/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.93.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-StyledString" class="impl"><a href="#impl-PartialEq-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a href="#method.eq" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="https://doc.rust-lang.org/1.93.0/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-StyledString" class="impl"><a href="#impl-Eq-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section><section id="impl-StructuralPartialEq-for-StyledString" class="impl"><a href="#impl-StructuralPartialEq-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">¬ß</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-StyledString" class="impl"><a href="#impl-Freeze-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section><section id="impl-RefUnwindSafe-for-StyledString" class="impl"><a href="#impl-RefUnwindSafe-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section><section id="impl-Send-for-StyledString" class="impl"><a href="#impl-Send-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section><section id="impl-Sync-for-StyledString" class="impl"><a href="#impl-Sync-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section><section id="impl-Unpin-for-StyledString" class="impl"><a href="#impl-Unpin-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section><section id="impl-UnwindSafe-for-StyledString" class="impl"><a href="#impl-UnwindSafe-for-StyledString" class="anchor">¬ß</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.StyledString.html" title="struct termionix_service::StyledString">StyledString</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">¬ß</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.93.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.93.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.93.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.93.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.93.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/clone.rs.html#547">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/clone.rs.html#549">Source</a><a href="#method.clone_to_uninit" class="anchor">¬ß</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.93.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.93.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.93.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/alloc/borrow.rs.html#85-87">Source</a><a href="#impl-ToOwned-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/alloc/borrow.rs.html#89">Source</a><a href="#associatedtype.Owned" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/alloc/borrow.rs.html#90">Source</a><a href="#method.to_owned" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.93.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/alloc/borrow.rs.html#94">Source</a><a href="#method.clone_into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.93.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.93.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.0/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.93.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details></div></section></div></main></body></html>